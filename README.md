# 文件压缩项目

## 1. 什么是压缩？

使用一种方式或者手段使得文件变的更小（可以还原）

例如：西安科技大学简称西科大

## 2. 为什么需要对文件进行压缩？

1. 文件太大，节省空间
2. 提高数据在网络上的传输效率
3. 对数据进行保护--加密，压缩前后的数据差距非常大，如果不知道具体的压缩算法即使得到了数据也不知道数据具体内容是什么

## 3. 文件压缩分类？

1. 无损压缩：源文件被压缩之后，通过解压缩如果能还原成和源文件完全一样。例如一个pdf文件，txt文件
2. 有损压缩：解压缩之后不能将其还原成与源文件完全相同，但是对于识别其中的内容没影响。例如视频的标清，超清，蓝光。

## 4. 如何进行压缩？

LZ77变形，原理将重复出现的语句用距离**长度对**来替换

压缩前：mnoabczxyuvwabc123456abczxydefgh

压缩后：mnoabczxyuvw(9,3)123456(18,6)defgh



基于Huffman编码的压缩：基于字节的压缩

一个字节8个bit位：如果对于每个字节能够找到一个更短的编码来改写数据，可以起到压缩的目的

压缩前：ABACBD

给每个字符找到新的编码：A-00, B-01, C-10, D-11

压缩后：000100100111

上面给的例子是**等长编码**，还有另一种**不等长编码**：A-100, B-101, C-11, D-0，在这种编码下D出现的越多则压缩效率越高。

C 的编码可以改为10吗？

不可以，改为10，C的编码就成为了A编码的前缀，将会造成歧义。

压缩过程？

1. 统计每个字符在文件中出现的个数
2. 创建Huffman树
3. 获取字符的编码
4. 用每个字符的编码重新改写源文件

## 5. Huffman树

带权路径长度WPL：所有路径的根路径长度与相应权值（叶节点的值）乘积之和

Huffman树：带权路径最小的二叉树（权值越大的叶节点越靠近根）

创建Huffman树：

1. 用户提供一组N个权值信息
2. 以每个权值为节点创建N棵二叉树的森林
3. 如果二叉树森林中超过两个树，进行一下操作
   1. 从二叉树森林中取出根节点权值最小的两棵二叉树
   2. 以这两棵二叉树作为某个节点的左右子树创建一棵新的二叉树，新二叉树的权值为其左右子树权值之和
   3. 将新创建的二叉树插入到森林中

Huffman树根节点是叶子节点的权值之和，权值是源文件中不同字符出现的次数，因此根节点的权值就是文件大小。



## 6. Huffman压缩遇到的问题

#### 文件打开 "b"

需要设置二进制方式打开文件。

遇到这个问题是文本文件经过压缩解压后少了一部分，测试很久，'}' 显示一半，'}}' 显示四分之三，'}}}'显示正常，根据问题显示看不出什么问题，于是逐步缩小范围，先确定压缩后的文件有没有问题，压缩后的没有问题，因此问题出现在解压缩，解压缩时没有出现乱码，而是出现少了一部分，可能是后半部分没有解压提前结束了，于是我想到了文件终止符 EOF，是个宏 -1，改用二进制方式打开文件，问题解决。

#### '\n' 和 '\0' 特殊处理

在统计文件中字符出现的次数时，一开始只考虑了 '\n' 的情况，忘记考虑 '\0'的情况，最开始使用文本文件测试的时候没有出现问题，但是压缩word文档和pdf文档的时候出现了问题，程序发生崩溃，经过测试定位发现是因为在统计 '\0' 字符个数的时候出现的问题，因为 '\0'是字符串的结尾，所以 '\0' 后边的字符就会被屏蔽掉，特殊处理一下。

#### 文件压缩后反而变大了



## 7. 什么是 LZ77

1977年两个以色列人提出的基于重复语句层面的一种通用的压缩算法。通用：对文件格式没有要求

最终是将重复语句替换成更短的 <长度，距离，先行缓冲区匹配字符串的下一个字符> 对，以达到压缩的目的。

替换前：mnoabczxyuvw**abc**123456**abczxy**defgh

替换后：mnoabczxyuvw(3,9,1)23456(6,18,d)efgh



LZ77变形，原理将重复出现的语句用 <长度，距离>对 来替换，长度占1个字节，距离占2个字节，匹配更远的距离

压缩前：mnoabczxyuvwabc123456abczxydefgh

压缩后：mnoabczxyuvw(9,3)123456(18,6)defgh



**ZIP：LZ77的变形从重复语句层面压缩 + huffman从字节层面进行压缩**



### 8. LZ77 压缩算法实现

如果要进行压缩，必须先要将文件中的带压缩数据读取到程序中的缓冲区中，因此程序中必须要有一块缓冲区

1. 该部分的数据已经压缩写到压缩文件中
2. 待压缩数据对应的一个字符串将来要在该区域中找重复
3. 随着压缩的进行，查找缓冲区在不断的增大

先行缓冲区

1. 待压缩的数据
2. 每次从该区域中取一个字符串，然后在查找换乘功能区中进行匹配
3. 随着压缩的进行，先行缓冲区在不断的缩小

有几个重复字符时进行长度距离对的替换？

1. 匹配字符串的长度用一个字节进行存储 [0,255]
2. 一个字节能够表示的最大值为255，能够满足大多数字符串重复的情况，如果用两个字节必然会对压缩率有一定的影响

距离用几个字节来存储？

1. 必须知道缓冲区有多大，缓冲区越大，查找到重复的概率就越高

2. 理论上应该在整个查找缓冲区中进行查找匹配，但是查找缓冲区越大查找的效率就会越低，因此在局部范围内进行查找（真正的匹配范围<WSIZE 32K），既要保证压缩率，也不能使压缩效率过于低。
3. 重复一般具有局部原理性，一定范围内的数据重复的可能性大，超过了范围重复的可能性就会变小
4. 如果查找范围过于远，两个字节就不能满足要求

<长度，距离>对 总共占了三个字节

​	1个重复字符：没有必要替换

​	2个重复字符：没有必要替换，否则压缩文件可能会变大

​	3个重复字符及以上进行替换 [3,258] 一共256个

​		MN_MATCH_LEN = 3;

​		MAX_MATCH_LEN = 258;

压缩的关键步骤：从先行缓冲区中取出三个字节，然后在查找缓冲区中找最长匹配，如何快速查找？

1. 暴力匹配
2. 利用哈希





## 直接采用huffman对LZ77结果进行压缩缺陷分析

1. 需要创建huffman树，如果文件中不同中字节出现比较多的情况下，huffman树将会很大，占用内存比较大，而且获取编码的效率会很低（通过递归方式获取编码）
2. huffman 树如果比较大，解压缩效率比较比较低。解压缩：不断从根节点往叶子节点的方向移动--重复的次数很多
3. 为了能够解压缩，压缩完成之后必须在压缩文件中保存字符频度信息。如果文件比较大，字符频度信息中为了保存字符出现的次数可能要使用比较大的空间，影响压缩比率
4. 直接压缩则LZ77压缩时写入文件的标记信息也会参与压缩过程，影响压缩率 



对于1、2、4的优化方案：不要直接采用huffman树---huffman树的变形：范式huffman树

#### 范式huffman树

范式huffman树是在huffman树的基础之上进行了一些强制性的约定，即：对于同一层节点中，所有的叶子节点都调整到左边，然后对于同一层的叶子节点按照符号顺序从小到大调整



范式huffman树的编码特性：

1. 高度在同一层的字符编码：递增

2. 如果不在同一层：下一层第一个编码等于上一层最后一个编码加1左移一位
3. 如果上一层不存在编码（叶子节点）则下一层编码等于上N层最后一个编码加1左移N位



由于范式huffman具有的编码特性，因此获取编码就不需要对树进行遍历

在计算叶子节点编码之前，需要拿到每个叶子节点的码字长度（编码长度：该叶子节点在树中的高度）