# FileCompress
# 文件压缩项目

## 1. 什么是压缩？

使用一种方式或者手段使得文件变的更小

## 2. 为什么需要对文件进行压缩？

1. 文件太大，节省空间
2. 提高数据在网络上的传输效率
3. 对数据进行保护--加密

## 3. 文件压缩分类？

1. 无损压缩：源文件被压缩之后，通过解压缩如果能还原成和源文件完全一样
2. 有损压缩：解压缩之后不能将其还原成与源文件完全相同--但是对于识别其中的内容没影响

## 4. 如何进行压缩？

GZIP：LZ77变形，原理将重复出现的语句用距离长度对来替换

压缩前：mnoabczxyuvwabc123456abczxydefgh

压缩后：mnoabczxyuvw(9,3)123456(18,6)defgh



基于Huffman编码的压缩：基于字节的压缩

一个字节--8个bit位：如果对于每个字节能够找到一个更短的编码来改写数据，可以起到压缩的目的

压缩前：ABACBD

给每个字符找到新的编码：A-00, B-01, C-10, D-11

压缩后：000100100111

上面给的例子是**等长编码**，还有另一种**不等长编码**：A-100, B-101, C-11, D-0，在这种编码下D出现的越多则压缩效率越高。

C 的编码可以改为10吗？

不可以，改为10，C的编码就成为了A编码的前缀，将会造成歧义。

压缩过程？

1. 统计每个字符在文件中出现的个数
2. 创建Huffman树
3. 获取字符的编码
4. 用每个字符的编码重新改写源文件

## Huffman树

带权路径长度WPL：所有路径的根路径长度与相应权值（叶节点的值）乘积之和

Huffman树：带权路径最小的二叉树（权值越大的叶节点越靠近根）

创建Huffman树：

1. 用户提供一组N个权值信息
2. 以每个权值为节点创建N棵二叉树的森林
3. 如果二叉树森林中超过两个树，进行一下操作
   1. 从二叉树森林中取出根节点权值最小的两棵二叉树
   2. 以这两棵二叉树作为某个节点的左右子树创建一棵新的二叉树，新二叉树的权值为其左右子树权值之和
   3. 将新创建的二叉树插入到森林中

Huffman树根节点是叶子节点的权值之和，权值是源文件中不同字符出现的次数，因此根节点的权值就是文件大小。